// Generated by CoffeeScript 1.3.3
(function() {
  var Lexer, NefPolyhedron, Scad, astNodes, builtin, csgNodes, extend, lexer, parser;

  Lexer = require("./lexer").Lexer;

  parser = require("./parser").parser;

  extend = require("./helpers").extend;

  astNodes = require('./ast');

  csgNodes = require('./csg');

  NefPolyhedron = require('./geometry').NefPolyhedron;

  builtin = require('./builtins');

  lexer = new Lexer;

  parser.lexer = {
    lex: function() {
      var tag, _ref;
      _ref = this.tokens[this.pos++] || [''], tag = _ref[0], this.yytext = _ref[1], this.yylineno = _ref[2];
      return tag;
    },
    setInput: function(tokens) {
      this.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function() {
      return "";
    }
  };

  parser.yy = astNodes;

  exports.Scad = Scad = (function() {

    function Scad() {}

    /*
      Set the file loader to be used
      by Scad#load(path).
      
      The file loader should be a 
      function that takes a file
      path and a callback, and returns
      the text contents of the file.
    */


    Scad.prototype.setFileLoader = function(fileLoader) {
      this.fileLoader = fileLoader;
    };

    /*
      Generate the effective AST given
      a file path. Uses the file loader
      from Scad#setFileLoader to load
      relevant files.
    */


    Scad.prototype.load = function(path, cb) {
      var _this = this;
      return this.fileLoader(path, function(text) {
        var ast, calls;
        ast = _this.parse(text);
        calls = 1;
        ast.replaceIncludes(function(path, replaceCb) {
          calls++;
          return _this.load(path, function(childAst) {
            replaceCb(childAst);
            calls--;
            if (calls === 0) {
              return cb(ast);
            }
          });
        });
        calls--;
        if (calls === 0) {
          return cb(ast);
        }
      });
    };

    /*
      Parse a string of SCAD code or an array of lexed tokens, and
      return the AST.
    */


    Scad.prototype.parse = function(source, options) {
      if (typeof source === 'string') {
        return parser.parse(lexer.tokenize(source, options));
      } else {
        return parser.parse(source);
      }
    };

    /*
      Evalutate an abstract syntax tree, yielding
      a CSG tree.
    */


    Scad.prototype.evalAst = function(ast) {
      var call, ctx;
      if (typeof ast === 'string' || !(ast instanceof astNodes.AstNode)) {
        ast = this.parse(ast);
      }
      ctx = new astNodes.Context;
      ctx._modules = builtin.modules;
      ctx._functions = builtin.functions;
      call = new astNodes.ModuleCall();
      return ast.evaluate(ctx, call);
    };

    /*
      Evaluate a CSG tree, yielding the final 3d output
      in the form of a NefPolyhedron object.
    */


    Scad.prototype.evalCsg = function(csgTree) {
      if (typeof csgTree === 'string' || !(csgTree instanceof csgNodes.CsgNode)) {
        csgTree = this.evalAst(csgTree);
      }
      return csgTree.evaluate();
    };

    Scad.prototype.render = function(nefPolyhedron) {
      if (typeof nefPolyhedron === 'string' || !(nefPolyhedron instanceof NefPolyhedron)) {
        return nefPolyhedron = this.evalCsg(nefPolyhedron);
      }
    };

    return Scad;

  })();

}).call(this);
