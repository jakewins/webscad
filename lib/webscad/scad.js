// Generated by CoffeeScript 1.4.0
(function() {
  var Lexer, Scad, astNodes, builtin, extend, lexer, parser;

  Lexer = require("./lexer").Lexer;

  parser = require("./parser").parser;

  extend = require("./helpers").extend;

  astNodes = require('./ast');

  builtin = require('./builtins');

  lexer = new Lexer;

  parser.lexer = {
    lex: function() {
      var tag, _ref;
      _ref = this.tokens[this.pos++] || [''], tag = _ref[0], this.yytext = _ref[1], this.yylineno = _ref[2];
      return tag;
    },
    setInput: function(tokens) {
      this.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function() {
      return "";
    }
  };

  parser.yy = astNodes;

  exports.Scad = Scad = (function() {

    function Scad() {}

    /*
      Set the file loader to be used
      by Scad#load(path).
      
      The file loader should be a 
      function that takes a file
      path and a callback, and returns
      the text contents of the file.
    */


    Scad.prototype.setFileLoader = function(fileLoader) {
      this.fileLoader = fileLoader;
    };

    /*
      Generate the effective AST given
      a file path. Uses the file loader
      from Scad#setFileLoader to load
      relevant files.
    */


    Scad.prototype.load = function(path, cb) {
      var _this = this;
      return this.fileLoader(path, function(text) {
        var ast, calls;
        try {
          ast = _this.parse(text);
        } catch (e) {
          if (e.message != null) {
            throw new Error("In '" + path + "': " + e.message);
          }
          elsethrow(new Error("In '" + path + "': " + e));
        }
        calls = 1;
        ast.replaceIncludes(function(path, replaceCb) {
          calls++;
          return _this.load(path, function(childAst) {
            replaceCb(childAst);
            calls--;
            if (calls === 0) {
              return cb(ast);
            }
          });
        });
        calls--;
        if (calls === 0) {
          return cb(ast);
        }
      });
    };

    /*
      Parse a string of SCAD code or an array of lexed tokens, and
      return the AST.
    */


    Scad.prototype.parse = function(source, options) {
      if (options == null) {
        options = {};
      }
      if (typeof source === 'string') {
        return parser.parse(lexer.tokenize(source, options));
      } else {
        return parser.parse(source);
      }
    };

    /*
      Evalutate an abstract syntax tree, yielding
      a CSG tree.
    */


    Scad.prototype.evaluate = function(ast) {
      var ctx;
      if (typeof ast === 'string' || !(ast instanceof astNodes.AstNode)) {
        ast = this.parse(ast);
      }
      ctx = new astNodes.Context;
      ctx._modules = builtin.modules;
      ctx._functions = builtin.functions;
      return ast.evaluate(ctx);
    };

    return Scad;

  })();

}).call(this);
