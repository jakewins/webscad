// Generated by CoffeeScript 1.4.0
(function() {
  var ASSIGNED, BOOL, CALLABLE, CODE, COMMENT, COMPARE, IDENTIFIER, INCLUDE_OR_USE, INDEXABLE, KEYWORDS, LINE_CONTINUER, LOGIC, Lexer, MULTILINER, NO_NEWLINE, NUMBER, OPERATOR, SIMPLESTR, TRAILING_SPACES, WHITESPACE, compact, count, last, starts, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require('./helpers'), count = _ref.count, starts = _ref.starts, compact = _ref.compact, last = _ref.last;

  exports.Lexer = Lexer = (function() {

    function Lexer() {}

    Lexer.prototype.tokenize = function(code, opts) {
      var i;
      if (opts == null) {
        opts = {};
      }
      if (WHITESPACE.test(code)) {
        code = "\n" + code;
      }
      code = code.replace(/\r/g, '').replace(TRAILING_SPACES, '');
      this.code = code;
      this.line = opts.line || 0;
      this.indent = 0;
      this.indebt = 0;
      this.outdebt = 0;
      this.indents = [];
      this.tokens = [];
      i = 0;
      while (this.chunk = code.slice(i)) {
        i += this.useOrIncludeToken() || this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.stringToken() || this.numberToken() || this.literalToken();
      }
      return this.tokens;
    };

    Lexer.prototype.identifierToken = function() {
      var colon, forcedIdentifier, id, input, match, prev, tag, _ref1;
      if (!(match = IDENTIFIER.exec(this.chunk))) {
        return 0;
      }
      input = match[0], id = match[1], colon = match[2];
      forcedIdentifier = colon || (prev = last(this.tokens)) && (((_ref1 = prev[0]) === '.' || _ref1 === '?.' || _ref1 === '::') || !prev.spaced && prev[0] === '@');
      tag = 'IDENTIFIER';
      if (__indexOf.call(KEYWORDS, id) >= 0) {
        tag = id.toUpperCase();
      }
      if (!forcedIdentifier) {
        tag = (function() {
          switch (id) {
            case '==':
            case '!=':
              return 'COMPARE';
            case '&&':
            case '||':
              return 'LOGIC';
            case 'true':
            case 'false':
            case 'null':
            case 'undef':
              return 'BOOL';
            case 'function':
              return 'FUNCTION';
            case 'module':
              return 'MODULE';
            default:
              return tag;
          }
        })();
      }
      this.token(tag, id);
      if (colon) {
        this.token(':', ':');
      }
      return input.length;
    };

    Lexer.prototype.useOrIncludeToken = function() {
      var match, path, type;
      if (!(match = INCLUDE_OR_USE.exec(this.chunk))) {
        return 0;
      }
      type = match[1];
      path = match[2];
      switch (type) {
        case 'include':
          this.token('INCLUDE', path);
          break;
        case 'use':
          this.token('USE', path);
          break;
        default:
          return 0;
      }
      return match[0].length;
    };

    Lexer.prototype.numberToken = function() {
      var match, number;
      if (!(match = NUMBER.exec(this.chunk))) {
        return 0;
      }
      number = match[0];
      this.token('NUMBER', number);
      return number.length;
    };

    Lexer.prototype.stringToken = function() {
      var match, string;
      switch (this.chunk.charAt(0)) {
        case "'":
          if (!(match = SIMPLESTR.exec(this.chunk))) {
            return 0;
          }
          this.token('STRING', (string = match[0]).replace(MULTILINER, '\\\n'));
          break;
        case '"':
          if (!(string = this.balancedString(this.chunk, '"'))) {
            return 0;
          }
          this.token('STRING', this.escapeLines(string));
          break;
        default:
          return 0;
      }
      this.line += count(string, '\n');
      return string.length;
    };

    Lexer.prototype.commentToken = function() {
      var block, comment, match;
      if (!(match = this.chunk.match(COMMENT))) {
        return 0;
      }
      comment = match[0], block = match[1];
      if (block) {
        this.token('COMMENT', this.sanitizeBlockComment(block, {
          blockcomment: true,
          indent: Array(this.indent + 1).join(' ')
        }));
      } else {
        this.token('COMMENT', comment.trim().slice(2).trim());
      }
      this.line += count(comment, '\n');
      return comment.length;
    };

    Lexer.prototype.whitespaceToken = function() {
      var match, nline, prev;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\n'))) {
        return 0;
      }
      prev = last(this.tokens);
      if (prev) {
        prev[match ? 'spaced' : 'newLine'] = true;
      }
      if (match) {
        return match[0].length;
      } else {
        return 0;
      }
    };

    Lexer.prototype.terminatorToken = function() {
      if (this.tag() !== 'TERMINATOR' && this.tokens.length > 0) {
        this.token('TERMINATOR', ';');
      }
      return this;
    };

    Lexer.prototype.literalToken = function() {
      var match, prev, tag, tok, twoTagsBack, value, _ref1, _ref2, _ref3;
      if (match = OPERATOR.exec(this.chunk)) {
        value = match[0];
      } else {
        value = this.chunk.charAt(0);
      }
      tag = value;
      prev = last(this.tokens);
      if (value === '=' && prev) {
        if (!prev[1].reserved && (_ref1 = prev[1], __indexOf.call(KEYWORDS, _ref1) >= 0)) {
          this.assignmentError();
        }
      }
      if (value === ';') {
        this.terminatorToken();
        return 1;
      } else if (value === '\n') {
        this.line += 1;
        return 1;
      } else if (__indexOf.call(COMPARE, value) >= 0) {
        tag = 'COMPARE';
      } else if (__indexOf.call(LOGIC, value) >= 0) {
        tag = 'LOGIC';
      } else if (prev && !prev.spaced) {
        if (value === '(') {
          if (this.tokens.length > 1) {
            twoTagsBack = this.tokens[this.tokens.length - 2][0];
          }
          if (twoTagsBack === 'FUNCTION' || twoTagsBack === 'MODULE') {
            tag = 'PARAM_START';
          } else if (_ref2 = prev[0], __indexOf.call(CALLABLE, _ref2) >= 0) {
            tag = 'CALL_START';
          }
        }
        if (value === ')') {
          tok = this.backtrackToOpeningTokenFor('(', ')');
          if (tok[0] === 'CALL_START') {
            tag = 'CALL_END';
          } else if (tok[0] === 'PARAM_START') {
            tag = 'PARAM_END';
          } else {
            tag = ')';
          }
        } else if (value === '[' && (_ref3 = prev[0], __indexOf.call(INDEXABLE, _ref3) >= 0)) {
          tag = 'INDEX_START';
        } else if (value === ']') {
          tok = this.backtrackToOpeningTokenFor('[', ']');
          if (tok[0] === 'INDEX_START') {
            tag = 'INDEX_END';
          } else {
            tag = ']';
          }
        }
      }
      this.token(tag, value);
      return value.length;
    };

    Lexer.prototype.sanitizeBlockComment = function(doc, options) {
      doc = doc.replace(/(\n\s|^)\*/g, '\n');
      return doc.trim();
    };

    Lexer.prototype.identifierError = function(word) {
      throw SyntaxError("Reserved word \"" + word + "\" on line " + (this.line + 1));
    };

    Lexer.prototype.assignmentError = function() {
      throw SyntaxError("Reserved word \"" + (this.value()) + "\" on line " + (this.line + 1) + " can't be assigned");
    };

    Lexer.prototype.balancedString = function(str, end) {
      var i, letter, prev, stack, _i, _ref1;
      stack = [end];
      for (i = _i = 1, _ref1 = str.length; 1 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
        switch (letter = str.charAt(i)) {
          case '\\':
            i++;
            continue;
          case end:
            stack.pop();
            if (!stack.length) {
              return str.slice(0, i + 1);
            }
            end = stack[stack.length - 1];
            continue;
        }
        if (end === '}' && (letter === '"' || letter === "'")) {
          stack.push(end = letter);
        } else if (end === '}' && letter === '{') {
          stack.push(end = '}');
        } else if (end === '"' && prev === '#' && letter === '{') {
          stack.push(end = '}');
        }
        prev = letter;
      }
      throw new Error("missing " + (stack.pop()) + ", starting on line " + (this.line + 1));
    };

    Lexer.prototype.token = function(tag, value) {
      return this.tokens.push([tag, value, this.line]);
    };

    Lexer.prototype.tag = function(index, tag) {
      var tok;
      return (tok = last(this.tokens, index)) && (tag ? tok[0] = tag : tok[0]);
    };

    Lexer.prototype.value = function(index, val) {
      var tok;
      return (tok = last(this.tokens, index)) && (val ? tok[1] = val : tok[1]);
    };

    Lexer.prototype.backtrackToOpeningTokenFor = function(openingSign, closingSign) {
      var i, stack, tok;
      stack = [];
      i = this.tokens.length;
      while (tok = this.tokens[--i]) {
        switch (tok[1]) {
          case closingSign:
            stack.push(tok);
            break;
          case openingSign:
            if (stack.length) {
              stack.pop();
            } else {
              return tok;
            }
        }
      }
      return null;
    };

    Lexer.prototype.unfinished = function() {
      var prev, value;
      return LINE_CONTINUER.test(this.chunk) || (prev = last(this.tokens, 1)) && prev[0] !== '.' && (value = this.value()) && !value.reserved && NO_NEWLINE.test(value) && !CODE.test(value) && !ASSIGNED.test(this.chunk);
    };

    Lexer.prototype.escapeLines = function(str, heredoc) {
      return str.replace(MULTILINER, heredoc ? '\\n' : '');
    };

    Lexer.prototype.makeString = function(body, quote, heredoc) {
      if (!body) {
        return quote + quote;
      }
      body = body.replace(/\\([\s\S])/g, function(match, contents) {
        if (contents === '\n' || contents === quote) {
          return contents;
        } else {
          return match;
        }
      });
      body = body.replace(RegExp("" + quote, "g"), '\\$&');
      return quote + this.escapeLines(body, heredoc) + quote;
    };

    return Lexer;

  })();

  KEYWORDS = ['true', 'false', 'undef', 'if', 'else', 'module', 'function'];

  INCLUDE_OR_USE = /^((?:use)|(?:include))\s<([^>]*)>/;

  IDENTIFIER = /^([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)([^\n\S]*:(?!:))?/;

  NUMBER = /^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;

  OPERATOR = /^(?:[-+*\/%<>&|^!?=]=|([-+:])\1|([&|<>])\2=?)/;

  WHITESPACE = /^[^\n\S]+/;

  COMMENT = /^\/\*((?:(?!\*\/)[\n\s\S])*)(?:\*\/[^\n\S]*|(?:\*\/)?$)|^(?:\s*\/\/.*)+/;

  CODE = /^\)\s+=/;

  SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;

  MULTILINER = /\n/g;

  ASSIGNED = /^\s*@?([$A-Za-z_][$\w\x7f-\uffff]*|['"].*['"])[^\n\S]*?[:=][^:=>]/;

  LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d]))/;

  TRAILING_SPACES = /\s+$/;

  NO_NEWLINE = /^(?:[-+*&|\/%=<>!.\\][<>=&|]*|and|or|is(?:nt)?|n(?:ot|ew)|delete|typeof|instanceof)$/;

  LOGIC = ['&&', '||'];

  COMPARE = ['==', '!=', '<', '>', '<=', '>='];

  BOOL = ['TRUE', 'FALSE', 'UNDEF'];

  CALLABLE = ['IDENTIFIER', 'STRING', ')', ']', 'CALL_END', 'INDEX_END'];

  INDEXABLE = CALLABLE.concat('NUMBER', 'BOOL');

}).call(this);
