// Generated by CoffeeScript 1.4.0
(function() {
  var Grid, Three, ThreeGeometryBuilder, ThreeRenderer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if (typeof THREE !== "undefined" && THREE !== null) {
    Three = THREE;
  } else {
    Three = require('../Three_module').Three;
  }

  Grid = require('./geometry').Grid;

  exports.ThreeGeometryBuilder = ThreeGeometryBuilder = (function() {

    function ThreeGeometryBuilder() {
      this.addFace = __bind(this.addFace, this);

    }

    ThreeGeometryBuilder.prototype.begin = function() {
      this.currentMaterialIdx = 0;
      this.geometry = new Three.Geometry();
      this.materials = [
        new Three.MeshBasicMaterial({
          color: 0xED374C
        })
      ];
      this.faces = [];
      this.verticeMap = new Grid();
      return this.vertexes = [];
    };

    ThreeGeometryBuilder.prototype.addFace = function(v1, v2, v3, v4) {
      var face, normal, _ref, _ref1;
      if (v4 == null) {
        v4 = null;
      }
      if (v4 === null) {
        _ref = [this._getOrCreateV(v1), this._getOrCreateV(v2), this._getOrCreateV(v3)], v1 = _ref[0], v2 = _ref[1], v3 = _ref[2];
        face = new Three.Face3(v1, v2, v3);
        face.centroid.addSelf(v1).addSelf(v2).addSelf(v3).divideScalar(3);
        face.normal = normal = face.centroid.clone().normalize();
        face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
      } else {
        _ref1 = [this._getOrCreateV(v1), this._getOrCreateV(v2), this._getOrCreateV(v3), this._getOrCreateV(v4)], v1 = _ref1[0], v2 = _ref1[1], v3 = _ref1[2], v4 = _ref1[3];
        face = new Three.Face4(v1, v2, v3, v4);
        face.centroid.addSelf(v1).addSelf(v2).addSelf(v3).addSelf(v4).divideScalar(4);
        face.normal = normal = face.centroid.clone().normalize();
        face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone(), normal.clone());
      }
      face.materialIndex = 0;
      this.currentMaterialIdx = this.currentMaterialIdx >= (this.materials.length - 2) ? 0 : this.currentMaterialIdx + 1;
      return this.faces.push(face);
    };

    ThreeGeometryBuilder.prototype.end = function() {
      this.geometry.materials = this.materials;
      this.geometry.vertices = this.vertexes;
      this.geometry.faces = this.faces;
      this.geometry.computeCentroids();
      this.geometry.computeVertexNormals();
      return this.geometry;
    };

    ThreeGeometryBuilder.prototype._getOrCreateV = function(point) {
      var vertex;
      if (!this.verticeMap.has(point)) {
        this.verticeMap.set(point, this.vertexes.length);
        vertex = new Three.Vector3(point[0], point[1], point[2]);
        this.vertexes.push(vertex);
      }
      return this.verticeMap.get(point);
    };

    ThreeGeometryBuilder.prototype._azimuth = function(vector) {
      return Math.atan2(vector.z, -vector.x);
    };

    ThreeGeometryBuilder.prototype._inclination = function(vector) {
      return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
    };

    return ThreeGeometryBuilder;

  })();

  exports.ThreeRenderer = ThreeRenderer = (function() {

    function ThreeRenderer() {
      this.builder = new ThreeGeometryBuilder();
    }

    /* Takes a NefPolyhedron, and converts it into
    a Three.js polyhedron.
    */


    ThreeRenderer.prototype.render = function(nefPolyhedron) {
      var currentHE, face, faceVertexes, firstHE, i, polyhedron, _i, _j, _len, _ref;
      polyhedron = nefPolyhedron.polyhedron;
      this.builder.begin();
      _ref = polyhedron.faces;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        face = _ref[_i];
        firstHE = face.halfEdge;
        currentHE = firstHE.next;
        while (true) {
          faceVertexes = [[firstHE.vertex.x, firstHE.vertex.y, firstHE.vertex.z]];
          for (i = _j = 0; _j <= 3; i = ++_j) {
            faceVertexes.push([currentHE.vertex.x, currentHE.vertex.y, currentHE.vertex.z]);
            currentHE = currentHE.next;
            if (currentHE === firstHE) {
              break;
            }
          }
          this.builder.addFace.apply(this, faceVertexes);
          if (currentHE === firstHE) {
            break;
          }
        }
      }
      return this.builder.end();
    };

    return ThreeRenderer;

  })();

}).call(this);
