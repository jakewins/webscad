// Generated by CoffeeScript 1.4.0

/* Full disclosure:
My current knowledge level of geometry
is something like "squares are a type of rectangle".
I apologize in advance if any of the documentation
below is rediculously incorrect. This is kind of a 
learning-by-doing experience.
*/


(function() {
  var DEBUG, Face, Grid, HalfEdge, HalfEdgeDataStructure, NefPolyhedron, Polyhedron, PolyhedronBuilder, Vertex,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  DEBUG = false;

  /* A vertex is a special type of point that
  specifies the beginning or end of a line.
  
  Our vertexes have three defining dimensions (x,y and z).
  */


  exports.Vertex = Vertex = (function() {

    function Vertex(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }

    Vertex.prototype.setHalfEdge = function(halfEdge) {
      this.halfEdge = halfEdge;
    };

    Vertex.prototype.toString = function() {
      return "V[" + this.x + "," + this.y + "," + this.z + "]";
    };

    return Vertex;

  })();

  /* A face is the area inside a polygon.
  */


  exports.Face = Face = (function() {

    function Face(plane) {
      this.plane = plane;
    }

    Face.prototype.setHalfEdge = function(halfEdge) {
      this.halfEdge = halfEdge;
    };

    Face.prototype.toString = function() {
      var nextHalfEdge, out, prevV;
      out = [];
      nextHalfEdge = this.halfEdge;
      while (nextHalfEdge != null) {
        prevV = nextHalfEdge.previous != null ? nextHalfEdge.previous.vertex : "null";
        out.push("(" + prevV + "->" + nextHalfEdge.vertex + ")");
        nextHalfEdge = nextHalfEdge.next;
        if (nextHalfEdge === this.halfEdge) {
          break;
        }
      }
      return "Face[" + out.join(" ") + "]";
    };

    return Face;

  })();

  exports.HalfEdge = HalfEdge = (function() {

    HalfEdge.IDS = 0;

    function HalfEdge(face, vertex) {
      this.face = face;
      this.vertex = vertex;
      this.id = HalfEdge.IDS++;
    }

    HalfEdge.prototype.isBorder = function() {
      return !(this.face != null);
    };

    HalfEdge.prototype.setPrevious = function(previous) {
      this.previous = previous;
    };

    HalfEdge.prototype.setNext = function(next) {
      this.next = next;
    };

    HalfEdge.prototype.setFace = function(face) {
      this.face = face;
    };

    HalfEdge.prototype.setVertex = function(vertex) {
      this.vertex = vertex;
    };

    HalfEdge.prototype.setOpposite = function(opposite) {
      this.opposite = opposite;
    };

    HalfEdge.prototype.toString = function() {
      var f, n, p, v;
      v = this.vertex != null ? this.vertex.toString() : "null";
      p = (this.previous != null) && (this.previous.vertex != null) ? this.previous.vertex.toString() : "null";
      n = (this.next != null) && (this.next.vertex != null) ? this.next.vertex.toString() : "null";
      f = (this.face != null) && (this.face.halfEdge != null) && (this.face.halfEdge.vertex != null) ? this.face.halfEdge.vertex.toString() : "null";
      return "HE(" + v + ")[p=" + p + ",n=" + n + ",f=" + f + "]";
    };

    return HalfEdge;

  })();

  /* Works as a low-level foundation
  for higher level geometric concepts, like
  polyhedrons.
  */


  exports.HalfEdgeDataStructure = HalfEdgeDataStructure = (function() {

    function HalfEdgeDataStructure() {
      this.faces = [];
      this.halfEdges = [];
      this.vertices = [];
    }

    HalfEdgeDataStructure.prototype.addVertex = function(vertex) {
      return this.vertices.push(vertex);
    };

    HalfEdgeDataStructure.prototype.addFace = function(face) {
      return this.faces.push(face);
    };

    HalfEdgeDataStructure.prototype.addHalfEdgePair = function(h, g) {
      h.setOpposite(g);
      g.setOpposite(h);
      this.halfEdges.push(h);
      this.halfEdges.push(g);
      return h;
    };

    return HalfEdgeDataStructure;

  })();

  exports.Polyhedron = Polyhedron = (function(_super) {

    __extends(Polyhedron, _super);

    function Polyhedron() {
      return Polyhedron.__super__.constructor.apply(this, arguments);
    }

    Polyhedron.prototype.toString = function() {
      var f, faces;
      faces = (function() {
        var _i, _len, _ref, _results;
        _ref = this.faces;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          f = _ref[_i];
          _results.push(f.toString());
        }
        return _results;
      }).call(this);
      faces = faces.join(",\n  ");
      if (faces.length > 0) {
        return "Polyhedron[\n  " + faces + "]";
      } else {
        return "Polyhedron[empty]";
      }
    };

    return Polyhedron;

  })(HalfEdgeDataStructure);

  exports.NefPolyhedron = NefPolyhedron = (function() {

    function NefPolyhedron(polyhedron) {
      this.polyhedron = polyhedron;
    }

    NefPolyhedron.prototype.complement = function() {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.interior = function() {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.closure = function() {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.boundary = function() {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.regularization = function() {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.intersection = function(other) {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.join = function(other) {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.difference = function(other) {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.symmetricDifference = function(other) {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.complement = function(other) {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.transform = function(transformation) {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.changeOrientation = function(full) {
      if (full == null) {
        full = false;
      }
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.isScaling = function(transformation) {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.is90DegreeRotation = function(transformation) {
      throw new Error("Not implemented");
    };

    NefPolyhedron.prototype.toString = function() {
      return "Nef[" + (this.polyhedron.toString()) + "]";
    };

    return NefPolyhedron;

  })();

  /* A coffeescript port of CGAL's
  Polyhedron_incremental_builder_3.
  
  This is used to create Polyhedrons by initially
  defining all vertexes in it, and then listing
  which vertexes make up each face.
  
  There is an important expectation when you use this,
  and it is in what "direction" around a face you list
  vertexes. You can only add an edge from A to B once.
  If you want to add it again (for a second face sharing
  that edge) you need to add it from B to A, eg. reversed.
  
  Lets say you wanted to create this partial polyhedron:
  
  A-----B
  \    / \
   \  /   \
    C-----D
  
  If you were to do:
  
      beginFace()
      addVertexToFace(A)
      addVertexToFace(B)
      addVertexToFace(C)
      endFace()
      beginFace()
      addVertexToFace(B)
      addVertexToFace(C)
      addVertexToFace(D)
      endFace()
  
  This would fail, because the builder thinks you want to 
  add the half-edge from B to C twice. You need to tell it
  you want it's opposite half edge, the one from C to B, associated
  with your second face, like so:
  
      beginFace()
      addVertexToFace(A)
      addVertexToFace(B)
      addVertexToFace(C)
      endFace()
      beginFace()
      addVertexToFace(C)
      addVertexToFace(B)
      addVertexToFace(D)
      endFace()
  */


  exports.PolyhedronBuilder = PolyhedronBuilder = (function() {
    /* Convert a list of polygons
    to a polyhedron.
    */

    PolyhedronBuilder.fromPolygons = function(polygons) {
      var builder, faceIsDegenerated, fc, i, point, polygon, v, vertex, vertexIds, vertexes, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m;
      vertexes = [];
      vertexIds = new Grid;
      builder = new PolyhedronBuilder;
      builder.begin();
      for (_i = 0, _len = polygons.length; _i < _len; _i++) {
        polygon = polygons[_i];
        for (_j = 0, _len1 = polygon.length; _j < _len1; _j++) {
          vertex = polygon[_j];
          if (!vertexIds.has(vertex)) {
            if (DEBUG) {
              console.log("Remembering vertex id: " + builder.newVertices + " -> ", vertex);
            }
            vertexIds.set(vertex, builder.newVertices);
            builder.addVertex(vertex);
          }
        }
      }
      i = 0;
      for (_k = 0, _len2 = polygons.length; _k < _len2; _k++) {
        polygon = polygons[_k];
        faceIsDegenerated = false;
        fc = {};
        for (_l = 0, _len3 = polygon.length; _l < _len3; _l++) {
          point = polygon[_l];
          v = vertexIds.get(point);
          if (!(fc[v] != null)) {
            fc[v] = 0;
          }
          if (fc[v]++ > 0) {
            faceIsDegenerated = true;
          }
        }
        if (!faceIsDegenerated) {
          builder.beginFace();
        }
        for (_m = 0, _len4 = polygon.length; _m < _len4; _m++) {
          point = polygon[_m];
          if (!faceIsDegenerated) {
            builder.addVertexToFace(vertexIds.get(point));
          }
        }
        if (!faceIsDegenerated) {
          builder.endFace();
        }
      }
      builder.end();
      return builder.getPolyhedron();
    };

    /* A simple API to create half-edge based
    polyhedrons.
    
    @param (optional) hds - A half-edge data structure, defaults to a new polyhedron instance.
    */


    function PolyhedronBuilder(hds) {
      this.hds = hds != null ? hds : new Polyhedron;
    }

    PolyhedronBuilder.prototype.getPolyhedron = function() {
      return this.hds;
    };

    PolyhedronBuilder.prototype.begin = function() {
      if (DEBUG) {
        console.log("=== Build Polyhedron ===");
      }
      this.indexToVertexMap = {};
      this.vertexToEdgeMap = {};
      this.newVertices = 0;
      this.newFaces = 0;
      this.newHalfedges = 0;
      return this;
    };

    PolyhedronBuilder.prototype.addVertex = function(point) {
      var vertex, x, y, z;
      x = point[0], y = point[1], z = point[2];
      vertex = new Vertex(x, y, z);
      this.hds.addVertex(vertex);
      this.indexToVertexMap[this.newVertices] = vertex;
      if (DEBUG) {
        console.log("Vertex: " + this.newVertices + ": ", vertex);
      }
      this.newVertices++;
      return this;
    };

    PolyhedronBuilder.prototype.beginFace = function() {
      if (DEBUG) {
        console.log("Face " + this.hds.faces.length + ":");
      }
      this.isFirstVertex = true;
      this.isFirstHalfedge = true;
      this.isLastVertex = false;
      this.currentFace = new Face();
      this.hds.addFace(this.currentFace);
      return this;
    };

    PolyhedronBuilder.prototype.addVertexToFace = function(vertexToAdd) {
      var currentHalfEdge, halfEdgeAfterPrevious, he, hole, holeHalfEdge, nextHalfEdge, nextIsBorder, prevIsBorder;
      if (DEBUG) {
        console.log(" Vertex " + this.indexToVertexMap[vertexToAdd]);
      }
      if (this.isFirstVertex) {
        this.firstVertex = vertexToAdd;
        this.isFirstVertex = false;
        return;
      }
      if (this.isFirstHalfedge) {
        this.firstHalfEdge = this.lookupHalfedge(this.firstVertex, vertexToAdd);
        this.prevHalfEdge = this.firstHalfEdge.next;
        this.prevVertex = this.secondVertex = vertexToAdd;
        this.isFirstHalfedge = false;
        return;
      }
      if (this.isLastVertex) {
        currentHalfEdge = this.firstHalfEdge;
      } else {
        currentHalfEdge = this.lookupHalfedge(this.prevVertex, vertexToAdd);
      }
      nextHalfEdge = currentHalfEdge.next;
      halfEdgeAfterPrevious = this.prevHalfEdge.next;
      this.prevHalfEdge.setNext(nextHalfEdge);
      nextHalfEdge.setPrevious(this.prevHalfEdge);
      if (!(this.vertexToEdgeMap[this.prevVertex] != null)) {
        nextHalfEdge.opposite.setNext(this.prevHalfEdge.opposite);
        this.prevHalfEdge.opposite.setPrevious(nextHalfEdge.opposite);
      } else {
        prevIsBorder = this.prevHalfEdge.opposite.isBorder();
        nextIsBorder = nextHalfEdge.opposite.isBorder();
        if (prevIsBorder && nextIsBorder) {
          holeHalfEdge = this.lookupHole(this.prevVertex);
          nextHalfEdge.opposite.setNext(holeHalfEdge.next);
          holeHalfEdge.next.setPrevious(nextHalfEdge.opposite);
          holeHalfEdge.setNext(this.prevHalfEdge.opposite);
          this.prevHalfEdge.opposite.setNext(holeHalfEdge);
        } else if (nextIsBorder) {
          nextHalfEdge.opposite.setNext(halfEdgeAfterPrevious);
          halfEdgeAfterPrevious.setPrevious(nextHalfEdge.opposite);
        } else if (prevIsBorder) {
          currentHalfEdge.setNext(this.prevHalfEdge.opposite);
          this.prevHalfEdge.opposite.setPrevious(currentHalfEdge);
        } else if (nextHalfEdge.opposite.next === this.prevHalfEdge.opposite) {
          if (this.prevHalfEdge.opposite.face !== nextHalfEdge.opposite.face) {
            throw new Error("Incorrect halfedge structure.");
          }
        } else {
          if (halfEdgeAfterPrevious !== nextHalfEdge) {
            currentHalfEdge.setNext(halfEdgeAfterPrevious);
            halfEdgeAfterPrevious.setPrevious(currentHalfEdge);
            he = this.prevHalfEdge;
            while (true) {
              if (he.isBorder()) {
                hole = he;
              }
              he = he.next.opposite;
              if (!(this.prevHalfEdge.next !== halfEdgeAfterPrevious && he !== this.prevHalfEdge)) {
                break;
              }
            }
            if (he === this.prevHalfEdge) {
              if (hole != null) {
                currentHalfEdge.setNext(hole.next);
                hole.next.setPrevious(currentHalfEdge);
                hole.setNext(halfEdgeAfterPrevious);
                halfEdgeAfterPrevious.setPrevious(hole);
              } else {
                throw new Error("Disconnected facet complexes at vertex " + this.prevVertex);
              }
            }
          }
        }
      }
      if (this.prevHalfEdge.vertex === this.indexToVertexMap[this.prevVertex]) {
        this.vertexToEdgeMap[this.prevVertex] = this.prevHalfEdge;
      }
      this.prevHalfEdge = nextHalfEdge;
      this.prevVertex = vertexToAdd;
      return this;
    };

    PolyhedronBuilder.prototype.endFace = function() {
      var he;
      this.addVertexToFace(this.firstVertex);
      this.isLastVertex = true;
      this.addVertexToFace(this.secondVertex);
      he = this.vertexToEdgeMap[this.secondVertex];
      this.currentFace.setHalfEdge(he);
      this.newFaces++;
      if (DEBUG) {
        console.log("/Face he=" + he);
        console.log(this.currentFace.toString());
      }
      return this;
    };

    PolyhedronBuilder.prototype.end = function() {
      return this;
    };

    PolyhedronBuilder.prototype.lookupHalfedge = function(startVertexId, endVertexId) {
      var endVertex, he, startEdge;
      if (this.vertexToEdgeMap[startVertexId] != null) {
        he = this.vertexToEdgeMap[startVertexId];
        if (this.currentFace === he.face) {
          throw new Error("Face " + this.newFaces + " has self-intersection at vertex " + startVertexId + ".");
        }
        startEdge = he;
        endVertex = this.indexToVertexMap[endVertexId];
        while (true) {
          if (he.next.vertex === endVertex) {
            if (!he.next.isBorder()) {
              throw new Error("Face " + this.newFaces + " shares a halfedge from vertex " + startVertexId + " with another face.");
            }
            if ((this.currentFace != null) && this.currentFace === he.next.opposite.face) {
              throw new Error("Face " + this.newFaces + " has a self intersection at the halfedge from vertex " + startVertexId + " to vertex " + endVertexId + ".");
            }
            he.next.setFace(this.currentFace);
            return he;
          }
          he = he.next.opposite;
          if (startEdge === he) {
            break;
          }
        }
      }
      he = this.hds.addHalfEdgePair(new HalfEdge(), new HalfEdge());
      this.newHalfedges += 2;
      he.setFace(this.currentFace);
      he.setVertex(this.indexToVertexMap[endVertexId]);
      he.setPrevious(he.opposite);
      he = he.opposite;
      he.setVertex(this.indexToVertexMap[startVertexId]);
      he.setNext(he.opposite);
      return he;
    };

    PolyhedronBuilder.prototype.lookupHole = function(he) {
      var first, startEdge;
      startEdge = he;
      first = true;
      while (he !== startEdge && !first) {
        first = false;
        if (he.next.isBorder()) {
          return he;
        }
        he = he.next.opposite;
      }
      throw new Error("A closed surface already exists, yet facet " + this.newFaces + " is still adjacent.");
    };

    PolyhedronBuilder.prototype.currentFaceStateToString = function() {
      var nextHalfEdge, out, prevV;
      if (this.isFirstVertex) {
        return "";
      }
      if (this.isFirstHalfedge) {
        return "(none)";
      }
      out = [];
      nextHalfEdge = this.firstHalfEdge;
      while (nextHalfEdge != null) {
        prevV = nextHalfEdge.previous != null ? nextHalfEdge.previous.vertex : "null";
        out.push(" (" + prevV + "-[" + nextHalfEdge.id + "]->" + nextHalfEdge.vertex + ")");
        nextHalfEdge = nextHalfEdge.next;
        if (nextHalfEdge === this.firstHalfEdge) {
          break;
        }
      }
      return out.join("");
    };

    return PolyhedronBuilder;

  })();

  /* A lookup table with an arbitrary number of dimensions,
  used to store and retrieve objects using points.
  
  You can use it as a two-dimensional structure:
  
    mygrid.set([0,0],"This is the object at 0,0")
    obj = mygrid.get([0,0])
  
  Or as a three dimensional one:
  
    mygrid.set([0,0,0],"This is the object at 0,0,0")
    obj = mygrid.get([0,0,0])
  
  Or any other number of dimensions.
  */


  exports.Grid = Grid = (function() {

    function Grid() {
      this.data = [];
    }

    Grid.prototype.set = function(pt, value) {
      var dimension, v, _i, _len, _ref;
      dimension = this.data;
      _ref = pt.slice(0, -1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        if (!(dimension[v] != null)) {
          dimension[v] = [];
        }
        dimension = dimension[v];
      }
      return dimension[pt[pt.length - 1]] = value;
    };

    Grid.prototype.get = function(pt) {
      var dimension, v, _i, _len;
      dimension = this.data;
      for (_i = 0, _len = pt.length; _i < _len; _i++) {
        v = pt[_i];
        if (!(dimension[v] != null)) {
          return void 0;
        }
        dimension = dimension[v];
      }
      return dimension;
    };

    Grid.prototype.has = function(pt) {
      return this.get(pt) !== void 0;
    };

    return Grid;

  })();

}).call(this);
