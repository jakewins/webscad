# The CoffeeScript parser is generated by [Jison](http://github.com/zaach/jison)
# from this grammar file. Jison is a bottom-up parser generator, similar in
# style to [Bison](http://www.gnu.org/software/bison), implemented in JavaScript.
# It can recognize [LALR(1), LR(0), SLR(1), and LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
# type grammars. To create the Jison parser, we list the pattern to match
# on the left-hand side, and the action to take (usually the creation of syntax
# tree nodes) on the right. As the parser runs, it
# shifts tokens from our token stream, from left to right, and
# [attempts to match](http://en.wikipedia.org/wiki/Bottom-up_parsing)
# the token sequence against the rules below. When a match can be made, it
# reduces into the [nonterminal](http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols)
# (the enclosing name at the top), and we proceed from there.
#
# If you run the `cake build:parser` command, Jison constructs a parse table
# from our rules and saves it into `lib/parser.js`.

# The only dependency is on the **jison.Parser**.
{Parser} = require 'jison'

# Jison DSL
# ---------

# Since we're going to be wrapped in a function by Jison in any case, if our
# action immediately returns a value, we can optimize by removing the function
# wrapper and just returning the value directly.
unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/

# Our handy DSL for Jison grammar generation, thanks to
# [Tim Caswell](http://github.com/creationix). For every rule in the grammar,
# we pass the pattern-defining string, the action to run, and extra options,
# optionally. If no action is specified, we simply pass the value of the
# previous nonterminal.
o = (patternString, action, options) ->
  patternString = patternString.replace /\s{2,}/g, ' '
  return [patternString, '$$ = $1;', options] unless action
  action = if match = unwrap.exec action then match[1] else "(#{action}())"
  action = action.replace /\bnew /g, '$&yy.'
  action = action.replace /\b(?:Block\.wrap|extend)\b/g, 'yy.$&'
  [patternString, "$$ = #{action};", options]

# Grammatical Rules
# -----------------

# In all of the rules that follow, you'll see the name of the nonterminal as
# the key to a list of alternative matches. With each match's action, the
# dollar-sign variables are provided by Jison as references to the value of
# their numeric position, so in this rule:
#
#     "Expression UNLESS Expression"
#
# `$1` would be the value of the first `Expression`, `$2` would be the token
# for the `UNLESS` terminal, and `$3` would be the value of the second
# `Expression`.
grammar =

  # The **Root** is the top-level node in the syntax tree. Since we parse bottom-up,
  # all parsing must end here.
  Root: [
    o '',                                       -> new Block
    o 'Body'
    o 'Block'
    o 'Block TERMINATOR'
  ]

  # A block is the body of a module, a list of statements.
  Block: [
    o '{ }',                                    -> new Block
    o '{ TERMINATOR }',                         -> new Block
    o '{ Body }',                               -> $2
    o '{ TERMINATOR Body }',                    -> $3
  ]

  # Any list of statements and expressions, separated by line breaks or semicolons.
  Body: [
    o 'Statement',                                   -> Block.wrap [$1]
    o 'Body TERMINATOR Statement',                   -> $1.push $3
    o 'Body TERMINATOR'
  ]

  # Statements
  Statement: [
    o 'Module'
    o 'ModuleCall'
    o 'Assign'
    o 'Code'
    o 'If'
    o 'Comment'
    o 'Include'
  ]

  # Expressions
  Expression: [
    o 'Value'
    o 'FunctionCall'
    o 'Operation'
    o 'Conditional'
  ]

  # A literal identifier, a variable name or property.
  Identifier: [
    o 'IDENTIFIER',                             -> new Identifier $1
  ]

  # Assignment of a variable, property, or index to a value.
  Assign: [
    o 'Assignable = Expression',                -> new Assign $1, $3
  ]

  # A comment.
  Comment: [
    o 'COMMENT',                                -> new Comment $1
  ]

  Code: [
    o 'FUNCTION Identifier PARAM_START ParamList PARAM_END = Expression', -> new Code $2, $4, $7
  ]

  # An optional, trailing comma.
  OptComma: [
    o ''
    o ','
  ]

  # The list of parameters that a function accepts can be of any length.
  ParamList: [
    o '',                                       -> []
    o 'Identifier',                             -> [$1]
    o 'ParamList , Identifier',                 -> $1.concat $3
  ]

  # Everything that can be assigned to.
  Assignable: [
    o 'Identifier'
    o 'BasicValue IndexAccess',                      -> new IndexAccess $1, $2
    o 'BasicValue MemberAccess',                     -> new MemberAccess $1, $2
  ]
  
  # Values that do not involve calling functions
  BasicValue: [
    o 'Assignable'
    o 'NUMBER',                                 -> new NumberValue $1
    o 'STRING',                                 -> new StringValue $1
    o 'BOOL',                                   ->
      if $1 is 'undef' then new UndefinedValue
      else new BooleanValue $1
    o 'Range'
    o 'Vector'
  ]

  # All things that can be treated as values
  Value: [
    o 'BasicValue'
    o 'FunctionCall IndexAccess',                 -> new IndexAccess $1, $2
    o 'FunctionCall MemberAccess',                -> new MemberAccess $1, $2
  ]  
  
  IndexAccess: [
    o 'INDEX_START Expression INDEX_END',       -> $2
  ]
  
  MemberAccess: [
    o '.  Identifier',                          -> $2
  ]

  Include: [
    o 'INCLUDE',                                -> new Include $1
    o 'USE',                                    -> new Use $1
  ]

  Module: [
    o 'MODULE Identifier PARAM_START ParamList PARAM_END Block', -> 
      new Module $2, $4, $6
  ]

  # Module invocation
  ModuleCall: [
    o 'Identifier Arguments',                        -> new ModuleCall $1, $2
    o '! ModuleCall', ->
      $2.setIsRoot(true)
    o '# ModuleCall', ->
      $2.setIsHighlighted(true)
    o '% ModuleCall', ->
      $2.setIsInBackground(true)
    o '* ModuleCall', ->
      $2.setIsIgnored(true)
    o 'Identifier Arguments ModuleCalls',   -> new ModuleCall $1, $2, $3
  ]
  
  # Child module invocations, this is the "block statement"
  # allowed in if constructs, in loops, and after module calls.
  ModuleCalls: [
    o 'ModuleCall',                       -> [$1]
    o '{ ModuleCallList }',               -> $2
  ]

  ModuleCallList: [
    o '',                                       -> []
    o 'ModuleCall',                       -> [$1]
    o 'ModuleCallList TERMINATOR ModuleCall', ->
      $1.concat $3
    o 'ModuleCallList TERMINATOR', -> $1
  ]

  # Function invocation
  FunctionCall: [
    o 'Identifier Arguments',                        -> new FunctionCall $1, $2
  ]

  # The list of arguments to a function call.
  Arguments: [
    o 'CALL_START CALL_END',                    -> new Arguments
    o 'CALL_START ArgList OptComma CALL_END',   -> new Arguments $2
  ]

  # Vector literal
  Vector: [
    o '[ ]',                                    -> new VectorValue []
    o '[ ArgList OptComma ]',                   -> new VectorValue $2
  ]

  # Ranges
  Range: [
    o '[ Expression : Expression ]', -> 
      new RangeValue $2, new NumberValue(1), $4
    o '[ Expression : Expression : Expression ]',-> 
      new RangeValue $2, $4, $6
  ]

  # The **ArgList** is both the list of objects passed into a function call,
  # as well as the contents of an array literal
  # (i.e. comma-separated expressions). Newlines work as well.
  ArgList: [
    o 'Arg',                                    -> [$1]
    o 'ArgList , Arg',                          -> $1.concat $3
    o 'ArgList OptComma TERMINATOR Arg',        -> $1.concat $4
  ]

  # Valid arguments are Expressions
  Arg: [
    o 'Expression'
    o 'Assign'
  ]
  
  # Conditional expressions
  Conditional: [
    o 'Expression ? Expression : Expression', ->
      new Conditional $1, $3, $5
  ]

  # The most basic form of *if* is a condition and an action. The following
  # if-related rules are broken up along these lines in order to avoid
  # ambiguity.
  IfBlock: [
    o 'IF ( Expression ) ModuleCalls',                -> new If $3, $5
    o 'IfBlock ELSE IF ( Expression ) ModuleCalls',       -> $1.addElse new If $5, $7
  ]

  # The full complement of *if* expressions
  If: [
    o 'IfBlock'
    o 'IfBlock ELSE ModuleCalls',                     -> $1.addElse $3
  ]

  # Arithmetic and logical operators, working on one or more operands.
  # Here they are grouped by order of precedence. The actual precedence rules
  # are defined at the bottom of the page. It would be shorter if we could
  # combine most of these rules into a single generic *Operand OpSymbol Operand*
  # -type rule, but in order to make the precedence binding possible, separate
  # rules are necessary.
  Operation: [
    o '! Expression',                           -> new Op '!', $2
    o '- Expression',                          (-> new Op '-', $2)
    o '+ Expression',                          (-> new Op '+', $2)
    
    o 'Expression +  Expression',               -> new Op '+' , $1, $3
    o 'Expression -  Expression',               -> new Op '-' , $1, $3
    o 'Expression *  Expression',               -> new Op '*' , $1, $3
    o 'Expression /  Expression',               -> new Op '/' , $1, $3
    o 'Expression %  Expression',               -> new Op '%' , $1, $3
    o 'Expression COMPARE  Expression',         -> new Op $2, $1, $3
    o 'Expression LOGIC    Expression',         -> new Op $2, $1, $3
  ]


# Precedence
# ----------

# Operators at the top of this list have higher precedence than the ones lower
# down. Following these rules is what makes `2 + 3 * 4` parse as:
#
#     2 + (3 * 4)
#
# And not:
#
#     (2 + 3) * 4
operators = [
  ['left',      '.']
  ['left',      'CALL_START', 'CALL_END']
  ['nonassoc',  '++', '--']
  ['right',     '!']
  ['left',      '*', '/', '%']
  ['left',      '+', '-']
  ['left',      'COMPARE']
  ['left',      'LOGIC']
  ['left',      '?']
  ['right',     '=', 'COMPOUND_ASSIGN']
  ['right',     'IF', 'ELSE', 'MODULE']
  ['right',     'POST_IF']
]

# Wrapping Up
# -----------

# Finally, now what we have our **grammar** and our **operators**, we can create
# our **Jison.Parser**. We do this by processing all of our rules, recording all
# terminals (every symbol which does not appear as the name of a rule above)
# as "tokens".
tokens = []
for name, alternatives of grammar
  grammar[name] = for alt in alternatives
    for token in alt[0].split ' '
      tokens.push token unless grammar[token]
    alt[1] = "return #{alt[1]}" if name is 'Root'
    alt

# Initialize the **Parser** with our list of terminal **tokens**, our **grammar**
# rules, and the name of the root. Reverse the operators because Jison orders
# precedence from low to high, and we have it high to low
# (as in [Yacc](http://dinosaur.compilertools.net/yacc/index.html)).
exports.parser = new Parser
  tokens      : tokens.join ' '
  bnf         : grammar
  operators   : operators.reverse()
  startSymbol : 'Root'
  moduleInclude : 'asd'
